Of course. I have updated the "Breeding Roller" code to incorporate the detailed new rules for age progression and the Celestial perks.

This was a significant update involving several key changes:

1.  **Age Perks Overhauled**: The internal `AgePerks` data object has been completely replaced with the new rules, including updated clutch sizes and the new `trait_pass_bonus`, `mutation_bonus`, and `rare_marking_bonus` values for Elders, Ancients, and Celestials.
2.  **Celestial Hereditary Traits**: The "Celestial Perk" dropdown has been updated with the new options (`Divine Blessing`, `Savage Boon`, `Prismatic Aura`). The calculation logic now correctly applies the corresponding bonus:
      * `Divine Blessing`: Increases the chance for rarer mane types.
      * `Savage Boon`: Increases the chance for a Destrier parent to pass on its species.
      * `Prismatic Aura`: Increases the chance to pass on rarer (recessive) base coat alleles.
3.  **Bonus Logic Refined**:
      * The "trait pass bonus" is now correctly applied only when a parent actually possesses the trait to pass on.
      * The "rare marking bonus" now correctly influences the genetic outcome by skewing the chances of a parent passing on their uncommon/rare marking alleles.
4.  **Random Mutation Chance**: A new mechanic has been added. Elder, Ancient, and Celestial parents now have a percentage chance to add a completely new mutation (one not present in the parents' genetics) to their offspring.

Here is the complete, updated HTML file with all the new logic implemented.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breeding Roller</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body { padding: 20px; background-color: #f8f9fa; }
        .container { max-width: 1100px; }
        .form-section { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .results-section { margin-top: 20px; }
        .form-control, .form-select { margin-bottom: 15px; }
        .error-message { color: red; display: none; }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="mb-4">Breeding Roller</h1>
        <div class="form-section">
            <h3>Parent A</h3>
            <div class="row">
                <div class="col-md-6">
                    <label for="parentA-species">Species:</label>
                    <select id="parentA-species" class="form-select">
                        <option value="Thilyarem">Thilyarem</option>
                        <option value="Destrier">Destrier</option>
                        <option value="Cyroas">Cyroas</option>
                    </select>
                </div>
                <div class="col-md-6">
                    <label for="parentA-age">Age:</label>
                    <select id="parentA-age" class="form-select">
                        <option value="Hatchling">Hatchling</option>
                        <option value="Juvenile">Juvenile</option>
                        <option value="Adolescent">Adolescent</option>
                        <option value="Young Adult" selected>Young Adult</option>
                        <option value="Adult">Adult</option>
                        <option value="Elder">Elder</option>
                        <option value="Ancient">Ancient</option>
                        <option value="Celestial">Celestial</option>
                    </select>
                </div>
            </div>
            <div class="row">
                <div class="col-md-6">
                    <label for="parentA-mane">Mane:</label>
                    <select id="parentA-mane" class="form-select">
                        <option value="Natural" selected>Natural</option>
                        <option value="Half">Half</option>
                        <option value="Full">Full</option>
                        <option value="Curly">Curly</option>
                        <option value="Maneless">Maneless</option>
                        <option value="Fiery">Fiery</option>
                        <option value="Silk">Silk</option>
                        <option value="Regal">Regal</option>
                    </select>
                </div>
                <div class="col-md-6">
                    <label for="parentA-element">Element:</label>
                    <select id="parentA-element" class="form-select">
                        <option value="Fire" selected>Fire</option>
                        <option value="Water">Water</option>
                        <option value="Air">Air</option>
                        <option value="Earth">Earth</option>
                        <option value="Metal">Metal</option>
                        <option value="Wood">Wood</option>
                        <option value="Ice">Ice</option>
                        <option value="Lightning">Lightning</option>
                        <option value="Light">Light</option>
                        <option value="Shadow">Shadow</option>
                        <option value="Aether">Aether</option>
                        <option value="Verdant">Verdant</option>
                    </select>
                </div>
            </div>
            <label for="parentA-genotype">Genotype:</label>
            <input type="text" id="parentA-genotype" class="form-control" placeholder="e.g., B+/BA M+/M+ K+/KB Spt Mrl/Mrl">

            <h3 class="mt-4">Parent B</h3>
            <div class="row">
                <div class="col-md-6">
                    <label for="parentB-species">Species:</label>
                    <select id="parentB-species" class="form-select">
                        <option value="Thilyarem">Thilyarem</option>
                        <option value="Destrier">Destrier</option>
                        <option value="Cyroas">Cyroas</option>
                    </select>
                </div>
                <div class="col-md-6">
                    <label for="parentB-age">Age:</label>
                    <select id="parentB-age" class="form-select">
                        <option value="Hatchling">Hatchling</option>
                        <option value="Juvenile">Juvenile</option>
                        <option value="Adolescent">Adolescent</option>
                        <option value="Young Adult" selected>Young Adult</option>
                        <option value="Adult">Adult</option>
                        <option value="Elder">Elder</option>
                        <option value="Ancient">Ancient</option>
                        <option value="Celestial">Celestial</option>
                    </select>
                </div>
            </div>
            <div class="row">
                <div class="col-md-6">
                    <label for="parentB-mane">Mane:</label>
                    <select id="parentB-mane" class="form-select">
                        <option value="Natural" selected>Natural</option>
                        <option value="Half">Half</option>
                        <option value="Full">Full</option>
                        <option value="Curly">Curly</option>
                        <option value="Maneless">Maneless</option>
                        <option value="Fiery">Fiery</option>
                        <option value="Silk">Silk</option>
                        <option value="Regal">Regal</option>
                    </select>
                </div>
                <div class="col-md-6">
                    <label for="parentB-element">Element:</label>
                    <select id="parentB-element" class="form-select">
                        <option value="Fire" selected>Fire</option>
                        <option value="Water">Water</option>
                        <option value="Air">Air</option>
                        <option value="Earth">Earth</option>
                        <option value="Metal">Metal</option>
                        <option value="Wood">Wood</option>
                        <option value="Ice">Ice</option>
                        <option value="Lightning">Lightning</option>
                        <option value="Light">Light</option>
                        <option value="Shadow">Shadow</option>
                        <option value="Aether">Aether</option>
                        <option value="Verdant">Verdant</option>
                    </select>
                </div>
            </div>
            <label for="parentB-genotype">Genotype:</label>
            <input type="text" id="parentB-genotype" class="form-control" placeholder="e.g., B+/BA M+/M+ K+/KB Spt Mrl/Mrl">

            <h3 class="mt-4">Breeding Items & Perks</h3>
            <div class="row">
                <div class="col-md-6">
                    <div class="form-check">
                        <input type="checkbox" id="crescent-herb" class="form-check-input">
                        <label for="crescent-herb" class="form-check-label">Crescent Herb</label>
                    </div>
                    <div class="form-check">
                        <input type="checkbox" id="moonlit-herb" class="form-check-input">
                        <label for="moonlit-herb" class="form-check-label">Moonlit Herb</label>
                    </div>
                </div>
                <div class="col-md-6">
                    <label for="celestial-perk">Celestial Hereditary Trait:</label>
                    <select id="celestial-perk" class="form-select">
                        <option value="None" selected>None</option>
                        <option value="Divine Blessing">Divine Blessing</option>
                        <option value="Savage Boon">Savage Boon</option>
                        <option value="Prismatic Aura">Prismatic Aura</option>
                    </select>
                </div>
            </div>

            <label for="coi">Coefficient of Inbreeding:</label>
            <select id="coi" class="form-select">
                <option value="None">None</option>
                <option value="Slight">Slight</option>
                <option value="Medium">Medium</option>
                <option value="High">High</option>
            </select>

            <button id="calculate-btn" class="btn btn-primary mt-3">Calculate Breeding</button>
            <div id="error-message" class="error-message mt-2"></div>
        </div>

        <div id="results" class="results-section"></div>
    </div>

<script>
    // Configuration constants
    const CONFIG = {
        BREEDING: {
            DEFAULT_CLUTCH: '1 - 3 eggs',
            DEFAULT_MANE: 'Natural',
            DEFAULT_ELEMENT: 'Fire'
        },
        LOGGING: {
            ENABLED: false,
            PREFIX: '[BreedingRoller]'
        }
    };

    // Simple logger replacement for browser
    const Logger = {
        log: (message) => {
            if (CONFIG.LOGGING.ENABLED) {
                console.log(message);
            }
        }
    };

    // Error Handler
    class ErrorHandler {
        static handle(error, context) {
            const message = `${CONFIG.LOGGING.PREFIX} Error in ${context}: ${error.message}\nStack: ${error.stack}`;
            if (CONFIG.LOGGING.ENABLED) Logger.log(message);
            document.getElementById('error-message').style.display = 'block';
            document.getElementById('error-message').innerText = `Error in ${context}: ${error.message}`;
            return message;
        }
    }

    // Enums and Data
    const Sex = { MALE: 'Male', FEMALE: 'Female' };
    const Breed = { THIL: 'Thilyarem', DEST: 'Destrier', CYROA: 'Cyroas' };
    const ScientificNames = {
        [Breed.THIL]: 'Panlongus lykophus pelagius',
        [Breed.DEST]: 'Panlongus lykophus imperator',
        [Breed.CYROA]: 'Panlongus murepera scirto'
    };
    const Age = { 
        HATCHLING: 'Hatchling', JUVENILE: 'Juvenile', ADOLESCENT: 'Adolescent', 
        YOUNG_ADULT: 'Young Adult', ADULT: 'Adult', ELDER: 'Elder', 
        ANCIENT: 'Ancient', CELESTIAL: 'Celestial' 
    };
    const Element = { 
        FIRE: 'Fire', WATER: 'Water', AIR: 'Air', EARTH: 'Earth', METAL: 'Metal', 
        WOOD: 'Wood', ICE: 'Ice', LIGHTNING: 'Lightning', LIGHT: 'Light', 
        SHADOW: 'Shadow', AETHER: 'Aether', VERDANT: 'Verdant' 
    };
    const GeneType = { BASE: 0, MARKING: 1, MUTATION: 2, MANE: 3, TRAIT: 4, MODIFIER: 5 };
    
    const Defects = {
        Common: ['Deafness', 'Blindness'],
        Uncommon: ['Slug Egg', 'Anosmia', 'Lameness', 'Hip Dysplasia'],
        Rare: ['Infertile', 'Malformed Tail', 'Malformed Limbs', 'Heart Disease'],
        VeryRare: ['Stillborn', 'Underdeveloped', 'Spinal Defect', 'Epilepsy'],
        Tiers: {
            Slight: ['Deafness', 'Blindness', 'Anosmia', 'Malformed Tail', 'Malformed Limbs'],
            Medium: ['Slug Egg', 'Stillborn', 'Underdeveloped', 'Infertile', 'Deafness', 'Blindness', 'Anosmia', 'Malformed Tail', 'Malformed Limbs'],
            High: ['Slug Egg', 'Stillborn', 'Underdeveloped', 'Infertile', 'Deafness', 'Blindness', 'Anosmia', 'Malformed Tail', 'Malformed Limbs', 'Lameness', 'Hip Dysplasia', 'Heart Disease', 'Spinal Defect', 'Epilepsy']
        }
    };

    // Updated AgePerks object with new rules
    const AgePerks = {
        [Age.HATCHLING]:    { breedable: false, clutch_min: 0, clutch_max: 0, trait_pass_bonus: 0, mutation_bonus: 0, rare_marking_bonus: 0 },
        [Age.JUVENILE]:     { breedable: false, clutch_min: 0, clutch_max: 0, trait_pass_bonus: 0, mutation_bonus: 0, rare_marking_bonus: 0 },
        [Age.ADOLESCENT]:   { breedable: true,  clutch_min: 0, clutch_max: 2, trait_pass_bonus: 0, mutation_bonus: 0, rare_marking_bonus: 0 },
        [Age.YOUNG_ADULT]:  { breedable: true,  clutch_min: 1, clutch_max: 3, trait_pass_bonus: 0, mutation_bonus: 0, rare_marking_bonus: 0 },
        [Age.ADULT]:        { breedable: true,  clutch_min: 1, clutch_max: 5, trait_pass_bonus: 0, mutation_bonus: 0, rare_marking_bonus: 0 },
        [Age.ELDER]:        { breedable: true,  clutch_min: 2, clutch_max: 4, trait_pass_bonus: 5, mutation_bonus: 10, rare_marking_bonus: 0 },
        [Age.ANCIENT]:      { breedable: true,  clutch_min: 2, clutch_max: 3, trait_pass_bonus: 10, mutation_bonus: 15, rare_marking_bonus: 5 },
        [Age.CELESTIAL]:    { breedable: true,  clutch_min: 2, clutch_max: 2, trait_pass_bonus: 15, mutation_bonus: 20, rare_marking_bonus: 10 }
    };

    const BreedMix = {
        [`${Breed.THIL}_${Breed.THIL}`]: { [Breed.THIL]: 100 },
        [`${Breed.THIL}_${Breed.DEST}`]: { [Breed.THIL]: 95, [Breed.DEST]: 5 },
        [`${Breed.DEST}_${Breed.THIL}`]: { [Breed.DEST]: 15, [Breed.THIL]: 85 },
        [`${Breed.DEST}_${Breed.DEST}`]: { [Breed.THIL]: 65, [Breed.DEST]: 35 },
        [`${Breed.CYROA}_${Breed.CYROA}`]: { [Breed.CYROA]: 100 },
        [`${Breed.THIL}_${Breed.CYROA}`]: { [Breed.THIL]: 50, [Breed.CYROA]: 50 },
        [`${Breed.CYROA}_${Breed.THIL}`]: { [Breed.CYROA]: 50, [Breed.THIL]: 50 },
        [`${Breed.CYROA}_${Breed.DEST}`]: { [Breed.CYROA]: 95, [Breed.DEST]: 5 }
    };
    
    const GeneMap = {
        VERMILLION: { TEXT: 'Vermillion', TYPE: GeneType.MODIFIER, EXPRESSED_SETS: [['R/R']], CARRIED_SETS: [['R/n']] },
        JADE: { TEXT: 'Jade', TYPE: GeneType.MODIFIER, EXPRESSED_SETS: [['J/J']], CARRIED_SETS: [['J/n']] },
        AMBER: { TEXT: 'Amber', TYPE: GeneType.MODIFIER, EXPRESSED_SETS: [['C/C']], CARRIED_SETS: [['C/n']] },
        PEARL: { TEXT: 'Pearl', TYPE: GeneType.MODIFIER, EXPRESSED_SETS: [['P/P']], CARRIED_SETS: [['P/n']] },
        DAPPLES: { TEXT: 'Dapples', TYPE: GeneType.MARKING, RARITY: 'Common', EXPRESSED_SETS: [['Dpl/Dpl'], ['Dpl/n']] },
        BELLYTONE: { TEXT: 'Bellytone', TYPE: GeneType.MARKING, RARITY: 'Common', EXPRESSED_SETS: [['Bt/Bt'], ['Bt/n']] },
        MANTLE: { TEXT: 'Mantle', TYPE: GeneType.MARKING, RARITY: 'Common', EXPRESSED_SETS: [['Mtl/Mtl'], ['Mtl/n']] },
        COLLAR: { TEXT: 'Collar', TYPE: GeneType.MARKING, RARITY: 'Common', EXPRESSED_SETS: [['Clr/Clr'], ['Clr/n']] },
        INKED: { TEXT: 'Inked', TYPE: GeneType.MARKING, RARITY: 'Common', EXPRESSED_SETS: [['Ikd/Ikd'], ['Ikd/n']] },
        SIAMESE: { TEXT: 'Siamese', TYPE: GeneType.MARKING, RARITY: 'Common', EXPRESSED_SETS: [['Sia/Sia'], ['Sia/n']] },
        POINTS: { TEXT: 'Points', TYPE: GeneType.MARKING, RARITY: 'Common', EXPRESSED_SETS: [['Pnt/Pnt'], ['Pnt/n']] },
        STAINED: { TEXT: 'Stained', TYPE: GeneType.MARKING, RARITY: 'Common', EXPRESSED_SETS: [['Stn/Stn'], ['Stn/n']] },
        ROAN: { TEXT: 'Roan', TYPE: GeneType.MARKING, RARITY: 'Common', EXPRESSED_SETS: [['Rn/Rn'], ['Rn/n']] },
        TABBY: { TEXT: 'Tabby', TYPE: GeneType.MARKING, RARITY: 'Common', EXPRESSED_SETS: [['Tby/Tby'], ['Tby/n']] },
        SPOTTED: { TEXT: 'Spotted', TYPE: GeneType.MARKING, RARITY: 'Common', EXPRESSED_SETS: [['Spt/Spt'], ['Spt/n']] },
        APPALOOSA: { TEXT: 'Appaloosa', TYPE: GeneType.MARKING, RARITY: 'Uncommon', EXPRESSED_SETS: [['Apl/Apl'], ['Apl/n']] },
        MERLE: { TEXT: 'Merle', TYPE: GeneType.MARKING, RARITY: 'Uncommon', EXPRESSED_SETS: [['Mrl/Mrl'], ['Mrl/n']] },
        BARRING: { TEXT: 'Barring', TYPE: GeneType.MARKING, RARITY: 'Uncommon', EXPRESSED_SETS: [['Brn/Brn'], ['Brn/n']] },
        DUN: { TEXT: 'Dun', TYPE: GeneType.MARKING, RARITY: 'Uncommon', EXPRESSED_SETS: [['Dn/Dn'], ['Dn/n']] },
        PYTHON: { TEXT: 'Python', TYPE: GeneType.MARKING, RARITY: 'Uncommon', EXPRESSED_SETS: [['Pyn/Pyn'], ['Pyn/n']] },
        STREAKS: { TEXT: 'Streaks', TYPE: GeneType.MARKING, RARITY: 'Uncommon', EXPRESSED_SETS: [['Stk/Stk'], ['Stk/n']] },
        OVERO: { TEXT: 'Overo', TYPE: GeneType.MARKING, RARITY: 'Uncommon', EXPRESSED_SETS: [['Ovr/Ovr'], ['Ovr/n']] },
        RORSCHACH: { TEXT: 'Rorschach', TYPE: GeneType.MARKING, RARITY: 'Uncommon', EXPRESSED_SETS: [['Rsc/Rsc'], ['Rsc/n']] },
        PANGARE: { TEXT: 'Pangare', TYPE: GeneType.MARKING, RARITY: 'Uncommon', EXPRESSED_SETS: [['Pg/Pg'], ['Pg/n']] },
        SABLE: { TEXT: 'Sable', TYPE: GeneType.MARKING, RARITY: 'Uncommon', EXPRESSED_SETS: [['Sb/Sb'], ['Sb/n']] },
        PIEBALD: { TEXT: 'Piebald', TYPE: GeneType.MARKING, RARITY: 'Rare', EXPRESSED_SETS: [['Pb/Pb'], ['Pb/n']] },
        GLINT: { TEXT: 'Glint', TYPE: GeneType.MARKING, RARITY: 'Rare', EXPRESSED_SETS: [['Gln/Gln'], ['Gln/n']] },
        SNOWFALL: { TEXT: 'Snowfall', TYPE: GeneType.MARKING, RARITY: 'Rare', EXPRESSED_SETS: [['Sf/Sf'], ['Sf/n']] },
        WIDOW: { TEXT: 'Widow', TYPE: GeneType.MARKING, RARITY: 'Rare', EXPRESSED_SETS: [['Wd/Wd'], ['Wd/n']] },
        DIAMOND: { TEXT: 'Diamond', TYPE: GeneType.MARKING, RARITY: 'Rare', EXPRESSED_SETS: [['Dmd/Dmd'], ['Dmd/n']] },
        SPIDER: { TEXT: 'Spider', TYPE: GeneType.MARKING, RARITY: 'Rare', EXPRESSED_SETS: [['Spr/Spr'], ['Spr/n']] },
        SPECTRUM: { TEXT: 'Spectrum', TYPE: GeneType.MARKING, RARITY: 'Rare', EXPRESSED_SETS: [['Stm/Stm'], ['Stm/n']] },
        IRIDESCENT: { TEXT: 'Iridescent', TYPE: GeneType.MARKING, RARITY: 'Rare', EXPRESSED_SETS: [['Iri/Iri'], ['Iri/n']] },
        VITILIGO: { TEXT: 'Vitiligo', TYPE: GeneType.MUTATION, RARITY: 'Common', EXPRESSED_SETS: [['Vit/Vit'], ['Vit/n']] },
        INVERSA: { TEXT: 'Inversa', TYPE: GeneType.MUTATION, RARITY: 'Uncommon', EXPRESSED_SETS: [['Inv/Inv'], ['Inv/n']] },
        LEUCISTIC: { TEXT: 'Leucistic', TYPE: GeneType.MUTATION, RARITY: 'Uncommon', EXPRESSED_SETS: [['Les/Les'], ['Les/n']] },
        ALBINO: { TEXT: 'Albino', TYPE: GeneType.MUTATION, RARITY: 'Uncommon', EXPRESSED_SETS: [['Alb/Alb'], ['Alb/n']] },
        'AXANTHIC-G': { TEXT: 'Axanthic-G', TYPE: GeneType.MUTATION, RARITY: 'Uncommon', EXPRESSED_SETS: [['Axg/Axg'], ['Axg/n']] },
        ERYTHRISTIC: { TEXT: 'Erythristic', TYPE: GeneType.MUTATION, RARITY: 'Rare', EXPRESSED_SETS: [['Ery/Ery'], ['Ery/n']] },
        'LAVENDER ALBINO': { TEXT: 'Lavender Albino', TYPE: GeneType.MUTATION, RARITY: 'Rare', EXPRESSED_SETS: [['Lva/Lva'], ['Lva/n']] },
        'AXANTHIC-M': { TEXT: 'Axanthic-M', TYPE: GeneType.MUTATION, RARITY: 'Rare', EXPRESSED_SETS: [['Axm/Axm'], ['Axm/n']] },
        CHIMERISM: { TEXT: 'Chimerism', TYPE: GeneType.MUTATION, RARITY: 'Very Rare', EXPRESSED_SETS: [['Cm/Cm'],['Cm/n']]},
        HORNED: { TEXT: 'Horned', TYPE: GeneType.TRAIT, RARITY: 'Uncommon', EXPRESSED_SETS: [['Hr/Hr'], ['Hr/n']] },
        FANGED: { TEXT: 'Fanged', TYPE: GeneType.TRAIT, RARITY: 'Uncommon', EXPRESSED_SETS: [['Fg/Fg'], ['Fg/n']] },
        SABRETEETH: { TEXT: 'Sabreteeth', TYPE: GeneType.TRAIT, RARITY: 'Rare', EXPRESSED_SETS: [['St/St'], ['St/n']] }
    };
    const SpontaneousMutations = ['Vit', 'Inv', 'Les', 'Alb', 'Axg', 'Ery', 'Lva', 'Axm'];

    const loci = [
        { locus: 'B', category: 'base', null_allele: 'n', genes: [
            { allele: 'B+', homozygous_genotype: 'B+/B+', heterozygous_genotypes: ['B+/BA', 'B+/BG', 'B+/BW'] },
            { allele: 'BA', homozygous_genotype: 'BA/BA', heterozygous_genotypes: ['BA/BG', 'BA/BW'] },
            { allele: 'BG', homozygous_genotype: 'BG/BG', heterozygous_genotypes: ['BG/BW'] },
            { allele: 'BW', homozygous_genotype: 'BW/BW', heterozygous_genotypes: [] }
        ]},
        { locus: 'M', category: 'base', null_allele: 'n', genes: [
            { allele: 'M+', homozygous_genotype: 'M+/M+', heterozygous_genotypes: ['M+/MB', 'M+/M0'] },
            { allele: 'MB', homozygous_genotype: 'MB/MB', heterozygous_genotypes: ['MB/M0'] },
            { allele: 'M0', homozygous_genotype: 'M0/M0', heterozygous_genotypes: [] }
        ]},
        { locus: 'K', category: 'base', null_allele: 'n', genes: [
            { allele: 'K+', homozygous_genotype: 'K+/K+', heterozygous_genotypes: ['K+/KB'] },
            { allele: 'KB', homozygous_genotype: 'KB/KB', heterozygous_genotypes: [] }
        ]},
        { locus: 'R', category: 'modifier', null_allele: 'n', genes: [{ allele: 'R' }] }, { locus: 'J', category: 'modifier', null_allele: 'n', genes: [{ allele: 'J' }] },
        { locus: 'C', category: 'modifier', null_allele: 'n', genes: [{ allele: 'C' }] }, { locus: 'P', category: 'modifier', null_allele: 'n', genes: [{ allele: 'P' }] },
        { locus: 'Dpl', category: 'marking', null_allele: 'n', genes: [{ allele: 'Dpl', rarity: 'Common' }] }, { locus: 'Bt', category: 'marking', null_allele: 'n', genes: [{ allele: 'Bt', rarity: 'Common' }] },
        { locus: 'Mtl', category: 'marking', null_allele: 'n', genes: [{ allele: 'Mtl', rarity: 'Common' }] }, { locus: 'Clr', category: 'marking', null_allele: 'n', genes: [{ allele: 'Clr', rarity: 'Common' }] },
        { locus: 'Ikd', category: 'marking', null_allele: 'n', genes: [{ allele: 'Ikd', rarity: 'Common' }] }, { locus: 'Sia', category: 'marking', null_allele: 'n', genes: [{ allele: 'Sia', rarity: 'Common' }] },
        { locus: 'Pnt', category: 'marking', null_allele: 'n', genes: [{ allele: 'Pnt', rarity: 'Common' }] }, { locus: 'Stn', category: 'marking', null_allele: 'n', genes: [{ allele: 'Stn', rarity: 'Common' }] },
        { locus: 'Rn', category: 'marking', null_allele: 'n', genes: [{ allele: 'Rn', rarity: 'Common' }] }, { locus: 'Tby', category: 'marking', null_allele: 'n', genes: [{ allele: 'Tby', rarity: 'Common' }] },
        { locus: 'Spt', category: 'marking', null_allele: 'n', genes: [{ allele: 'Spt', rarity: 'Common' }] }, { locus: 'Apl', category: 'marking', null_allele: 'n', genes: [{ allele: 'Apl', rarity: 'Uncommon' }] },
        { locus: 'Mrl', category: 'marking', null_allele: 'n', genes: [{ allele: 'Mrl', rarity: 'Uncommon' }] }, { locus: 'Brn', category: 'marking', null_allele: 'n', genes: [{ allele: 'Brn', rarity: 'Uncommon' }] },
        { locus: 'Dn', category: 'marking', null_allele: 'n', genes: [{ allele: 'Dn', rarity: 'Uncommon' }] }, { locus: 'Pyn', category: 'marking', null_allele: 'n', genes: [{ allele: 'Pyn', rarity: 'Uncommon' }] },
        { locus: 'Stk', category: 'marking', null_allele: 'n', genes: [{ allele: 'Stk', rarity: 'Uncommon' }] }, { locus: 'Ovr', category: 'marking', null_allele: 'n', genes: [{ allele: 'Ovr', rarity: 'Uncommon' }] },
        { locus: 'Rsc', category: 'marking', null_allele: 'n', genes: [{ allele: 'Rsc', rarity: 'Uncommon' }] }, { locus: 'Pg', category: 'marking', null_allele: 'n', genes: [{ allele: 'Pg', rarity: 'Uncommon' }] },
        { locus: 'Sb', category: 'marking', null_allele: 'n', genes: [{ allele: 'Sb', rarity: 'Uncommon' }] }, { locus: 'Pb', category: 'marking', null_allele: 'n', genes: [{ allele: 'Pb', rarity: 'Rare' }] },
        { locus: 'Gln', category: 'marking', null_allele: 'n', genes: [{ allele: 'Gln', rarity: 'Rare' }] }, { locus: 'Sf', category: 'marking', null_allele: 'n', genes: [{ allele: 'Sf', rarity: 'Rare' }] },
        { locus: 'Wd', category: 'marking', null_allele: 'n', genes: [{ allele: 'Wd', rarity: 'Rare' }] }, { locus: 'Dmd', category: 'marking', null_allele: 'n', genes: [{ allele: 'Dmd', rarity: 'Rare' }] },
        { locus: 'Spr', category: 'marking', null_allele: 'n', genes: [{ allele: 'Spr', rarity: 'Rare' }] }, { locus: 'Stm', category: 'marking', null_allele: 'n', genes: [{ allele: 'Stm', rarity: 'Rare' }] },
        { locus: 'Iri', category: 'marking', null_allele: 'n', genes: [{ allele: 'Iri', rarity: 'Rare' }] }, { locus: 'Vit', category: 'mutation', null_allele: 'n', genes: [{ allele: 'Vit' }] },
        { locus: 'Inv', category: 'mutation', null_allele: 'n', genes: [{ allele: 'Inv' }] }, { locus: 'Les', category: 'mutation', null_allele: 'n', genes: [{ allele: 'Les' }] },
        { locus: 'Alb', category: 'mutation', null_allele: 'n', genes: [{ allele: 'Alb' }] }, { locus: 'Axg', category: 'mutation', null_allele: 'n', genes: [{ allele: 'Axg' }] },
        { locus: 'Ery', category: 'mutation', null_allele: 'n', genes: [{ allele: 'Ery' }] }, { locus: 'Lva', category: 'mutation', null_allele: 'n', genes: [{ allele: 'Lva' }] },
        { locus: 'Axm', category: 'mutation', null_allele: 'n', genes: [{ allele: 'Axm' }] }, { locus: 'Cm', category: 'mutation', null_allele: 'n', genes: [{ allele: 'Cm' }] },
        { locus: 'Hr', category: 'trait', null_allele: 'n', genes: [{ allele: 'Hr' }] }, { locus: 'Fg', category: 'trait', null_allele: 'n', genes: [{ allele: 'Fg' }] },
        { locus: 'St', category: 'trait', null_allele: 'n', genes: [{ allele: 'St' }] }
    ];

    // Helper Classes
    class GenotypeHelper {
        static sliceGenotype(genotype) {
            try {
                if (!genotype || typeof genotype !== 'string') return [];
                return genotype.trim().split(/\s+/).filter(g => g);
            } catch (e) { ErrorHandler.handle(e, 'sliceGenotype'); return []; }
        }
    
        static getAlleles(genes, loci_data) {
            try {
                if (!Array.isArray(genes) || !Array.isArray(loci_data)) throw new Error('Invalid input types');
                const alleles = {};
                const geneSet = new Set(genes);
    
                for (const locusInfo of loci_data) {
                    const locus = locusInfo.locus;
                    let foundAllelePair = null;
    
                    for (const geneStr of geneSet) {
                        const firstPart = geneStr.split('/')[0];
                        if (locusInfo.genes.some(g => g.allele === firstPart)) {
                            foundAllelePair = geneStr;
                            break;
                        }
                    }
    
                    if (foundAllelePair) {
                        alleles[locus] = foundAllelePair.includes('/') ? foundAllelePair.split('/') : [foundAllelePair, locusInfo.null_allele];
                    } else {
                        alleles[locus] = [locusInfo.null_allele, locusInfo.null_allele];
                    }
    
                    if (locus === 'K' && alleles[locus][0] === 'n' && alleles[locus][1] === 'n') {
                        alleles[locus] = ['K+', 'K+'];
                    }
                }
                return alleles;
            } catch (e) { ErrorHandler.handle(e, 'getAlleles'); throw new Error('Invalid genotype format.'); }
        }
    }

    class PhenotypeHelper {
        static phenotypeCache = new Map();
        static getPhenotype(genes, mane) {
             try {
                const cacheKey = `${genes.join('|')}|${mane}`;
                if (this.phenotypeCache.has(cacheKey)) return this.phenotypeCache.get(cacheKey);

                const has = (allele) => genes.some(g => g === allele);
                const hasAllele = (allele) => genes.some(g => g.includes(allele));

                let baseCoat = 'Tan'; // Default

                const isBplus = hasAllele('B+');
                const hasMplus = hasAllele('M+');
                const isKBhomozygous = has('KB/KB');

                if (isKBhomozygous) {
                    if (hasMplus) {
                        baseCoat = 'Black';
                    } else if (isBplus) { 
                        baseCoat = has('M0/M0') ? 'Cream' : 'Tan';
                    } else if (has('BA/BA') || has('B+/BA') || has('BA/BG') || has('BA/BW')) {
                        baseCoat = has('M0/M0') ? 'Lilac' : 'Brown';
                    } else if (has('BG/BG') || has('B+/BG') || has('BG/BW')) {
                        baseCoat = has('M0/M0') ? 'Seafoam' : has('MB/MB') ? 'Seagreen' : 'Green';
                    } else if (has('BW/BW') || has('B+/BW')) {
                        baseCoat = has('M0/M0') ? 'White' : has('MB/MB') ? 'Blue' : 'Slate';
                    }
                } else {
                    if (isBplus) {
                        baseCoat = has('M0/M0') ? 'Cream' : 'Tan';
                    } else if (has('BA/BA') || has('BA/BG') || has('BA/BW')) {
                        baseCoat = has('M0/M0') ? 'Lilac' : 'Brown';
                    } else if (has('BG/BG') || has('BG/BW')) {
                        baseCoat = has('M0/M0') ? 'Seafoam' : has('MB/MB') ? 'Seagreen' : 'Green';
                    } else if (has('BW/BW')) {
                        baseCoat = has('M0/M0') ? 'White' : has('MB/MB') ? 'Blue' : 'Slate';
                    }
                }

                if (has('R/R')) baseCoat = 'Vermillion';
                else if (has('J/J')) baseCoat = 'Jade';
                else if (has('C/C')) baseCoat = 'Amber';
                else if (has('P/P')) baseCoat = 'Pearl';

                let expressed = [];
                const carried = [];
                const allPhenos = Object.values(GeneMap);
                for (const pheno of allPhenos) {
                    if (pheno.TYPE !== GeneType.BASE && pheno.TYPE !== GeneType.MANE) {
                        if (pheno.EXPRESSED_SETS?.some(set => set.every(gene => has(gene)))) {
                           expressed.push(pheno.TEXT);
                        } else if (pheno.CARRIED_SETS?.some(set => set.every(gene => has(gene)))) {
                            carried.push(`Carries ${pheno.TEXT}`);
                        }
                    }
                }
                
                let phenoString = `${baseCoat} with ${mane} Mane`;
                const markings = expressed.filter(p => GeneMap[p.toUpperCase().replace(/\s/g, '')]?.TYPE === GeneType.MARKING);
                if (markings.length) phenoString += ` / ${markings.join(' / ')}`;
                const traits = expressed.filter(p => GeneMap[p.toUpperCase()]?.TYPE === GeneType.TRAIT);
                if (traits.length) phenoString += ` [${traits.join(', ')}]`;
                const mutations = expressed.filter(p => GeneMap[p.toUpperCase().replace(/\s|-/g, '')]?.TYPE === GeneType.MUTATION);
                if (mutations.length) phenoString += ` {${mutations.join(', ')}}`;
                if (carried.length) phenoString += ` (${carried.join(', ')})`;

                this.phenotypeCache.set(cacheKey, phenoString);
                return phenoString;
            } catch (e) { ErrorHandler.handle(e, 'getPhenotype'); return 'Error calculating phenotype'; }
        }
    }

    class PunnettHelper {
        static getPossibleClutchSize(p_a, p_b, items) {
            try {
                const perkA = AgePerks[p_a.age] || AgePerks[Age.YOUNG_ADULT];
                const perkB = AgePerks[p_b.age] || AgePerks[Age.YOUNG_ADULT];
                let min = Math.min(perkA.clutch_min, perkB.clutch_min);
                let max = Math.max(perkA.clutch_max, perkB.clutch_max) + (items.crescent_herb ? 2 : 0) + (items.moonlit_herb ? 2 : 0);
                return min === max ? `${min} ${min === 1 ? 'egg' : 'eggs'}` : `${min} - ${max} eggs`;
            } catch (e) { ErrorHandler.handle(e, 'getPossibleClutchSize'); return CONFIG.BREEDING.DEFAULT_CLUTCH; }
        }

        static getSexOdds() { return { [Sex.MALE]: 50, [Sex.FEMALE]: 50 }; }

        static getBreedOdds(parentA, parentB, celestialPerk) {
            let odds = {...(BreedMix[`${parentA.species}_${parentB.species}`] || BreedMix[`${parentB.species}_${parentA.species}`] || (parentA.species === parentB.species ? { [parentA.species]: 100 } : { [parentA.species]: 50, [parentB.species]: 50 }))};
            if (celestialPerk === 'Savage Boon' && (parentA.age === Age.CELESTIAL || parentB.age === Age.CELESTIAL)) {
                if(odds[Breed.DEST] && odds[Breed.DEST] < 100) {
                    odds[Breed.DEST] += 5;
                    // Find another breed to subtract from
                    const otherBreed = Object.keys(odds).find(b => b !== Breed.DEST);
                    if(otherBreed) odds[otherBreed] -= 5;
                }
            }
            return odds;
        }

        static getGametes(parent, locusInfo) {
            const alleles = parent.alleles[locusInfo.locus];
            let [a1, a2] = alleles;
            let chanceA1 = 0.5;

            const perk = AgePerks[parent.age];
            if (!perk) return { [a1]: 0.5, [a2]: 0.5 };
            
            let bonus = 0;
            // Rare marking bonus
            if (locusInfo.category === 'marking' && perk.rare_marking_bonus > 0) {
                 const geneInfo = locusInfo.genes.find(g => g.allele === a1 || g.allele === a2);
                 if (geneInfo && (geneInfo.rarity === 'Uncommon' || geneInfo.rarity === 'Rare')) {
                     bonus = perk.rare_marking_bonus;
                 }
            }
            // Prismatic Aura bonus for base coats
            if (locusInfo.category === 'base' && parent.celestialPerk === 'Prismatic Aura') {
                const recessiveAlleles = ['BA', 'BG', 'BW', 'MB', 'M0', 'KB'];
                if(recessiveAlleles.includes(a1) || recessiveAlleles.includes(a2)) {
                    bonus = 5;
                }
            }
            
            if (bonus > 0) {
                 if (a1 !== locusInfo.null_allele && a2 === locusInfo.null_allele) { // Heterozygous dominant
                    chanceA1 += bonus / 100;
                 } else if (a1 === locusInfo.null_allele && a2 !== locusInfo.null_allele) { // Heterozygous recessive (just in case)
                     //This case shouldn't happen with sorted alleles, but good to handle
                     chanceA1 -= bonus / 100;
                 }
            }
            chanceA1 = Math.max(0, Math.min(1, chanceA1));
            return { [a1]: chanceA1, [a2]: 1 - chanceA1 };
        }

        static getPunnettOdds(parentA, parentB) {
            try {
                const odds = {};
                for (const locusInfo of loci) {
                    const gametesA = this.getGametes(parentA, locusInfo);
                    const gametesB = this.getGametes(parentB, locusInfo);
                    
                    const outcomes = {};
                    const dominanceOrder = (locusInfo.genes.map(g => g.allele)).concat([locusInfo.null_allele]);
                    const sortAlleles = (p1, p2) => {
                        const index1 = dominanceOrder.indexOf(p1);
                        const index2 = dominanceOrder.indexOf(p2);
                        return index1 <= index2 ? [p1, p2] : [p2, p1];
                    };
                    
                    for (const [alleleA, probA] of Object.entries(gametesA)) {
                        for (const [alleleB, probB] of Object.entries(gametesB)) {
                            let sorted = sortAlleles(alleleA, alleleB);
                            if (locusInfo.locus === 'K' && sorted[0] === 'n' && sorted[1] === 'n') {
                                sorted = ['K+', 'K+'];
                            }
                            const genotype = sorted.join('/');
                            outcomes[genotype] = (outcomes[genotype] || 0) + (probA * probB);
                        }
                    }
                    
                    odds[locusInfo.locus] = Object.entries(outcomes).map(([geno, prob]) => [geno, prob * 100]);
                }
                return odds;
            } catch (e) { ErrorHandler.handle(e, 'getPunnettOdds'); throw new Error('Error calculating genotype odds'); }
        }
    }
    
    function getTraitOdds(items, parentA, parentB) {
        try {
            const odds = {};
            const traits = ['Horned', 'Fanged', 'Sabreteeth'];
            const perkA = AgePerks[parentA.age] || {};
            const perkB = AgePerks[parentB.age] || {};

            traits.forEach(traitName => {
                const traitInfo = GeneMap[traitName.toUpperCase()];
                if (!traitInfo) return;

                const allele = traitInfo.EXPRESSED_SETS[0][0].split('/')[0];
                const hasTraitA = parentA.genotype.includes(allele);
                const hasTraitB = parentB.genotype.includes(allele);
                
                let baseChance = 10;
                let bonus = 0;
                if (hasTraitA || hasTraitB) {
                    baseChance = 50;
                    // Apply bonus only if trait is present
                    bonus = Math.max(hasTraitA ? (perkA.trait_pass_bonus || 0) : 0, hasTraitB ? (perkB.trait_pass_bonus || 0) : 0);
                }
                odds[traitName] = baseChance + bonus + (items.moonlit_herb ? 10 : 0);
            });
            return odds;
        } catch (e) { ErrorHandler.handle(e, 'getTraitOdds'); return { Horned: 10, Fanged: 10, Sabreteeth: 5 }; }
    }

    function getManeOdds(maneA, maneB, celestialPerk, parentAgeA, parentAgeB) {
        const maneRules = {
            'Natural_Natural': { 'Natural': 75, 'Half': 20, 'Full': 5 }, 'Natural_Half': { 'Natural': 55, 'Half': 43, 'Maneless': 2 },
            'Natural_Full': { 'Natural': 50, 'Full': 45, 'Curly': 5 }, 'Natural_Curly': { 'Natural': 40, 'Full': 45, 'Curly': 15 },
            'Natural_Maneless': { 'Natural': 40, 'Half': 55, 'Maneless': 5 }, 'Natural_Fiery': { 'Natural': 60, 'Full': 10, 'Curly': 25, 'Fiery': 5 },
            'Natural_Silk': { 'Natural': 50, 'Full': 25, 'Curly': 20, 'Silk': 5 }, 'Natural_Regal': { 'Full': 40, 'Natural': 20, 'Curly': 10, 'Fiery': 25, 'Regal': 5 },
            'Half_Half': { 'Natural': 20, 'Half': 70, 'Maneless': 10 }, 'Half_Full': { 'Natural': 20, 'Half': 40, 'Full': 40 }, 
            'Half_Curly': { 'Natural': 30, 'Half': 30, 'Full': 30, 'Curly': 10 }, 'Half_Maneless': {'Natural': 30, 'Half': 40, 'Maneless': 30},
            'Full_Full': { 'Natural': 10, 'Full': 80, 'Curly': 10 }, 'Curly_Curly': { 'Full': 20, 'Curly': 80 },
            'Maneless_Maneless': { 'Maneless': 100 }, 'Fiery_Fiery': { 'Fiery': 80, 'Curly': 20}, 'Silk_Silk': {'Silk': 80, 'Full': 20}, 'Regal_Regal': {'Regal': 80, 'Fiery': 20}
        };

        const key = `${maneA}_${maneB}`;
        const reverseKey = `${maneB}_${maneA}`;
        let rule = maneRules[key] || maneRules[reverseKey] || { [maneA]: 50, [maneB]: 50 };
        
        const allManes = ['Natural', 'Half', 'Full', 'Curly', 'Maneless', 'Fiery', 'Silk', 'Regal'];
        let odds = {};
        allManes.forEach(mane => { odds[mane] = rule[mane] || 0; });
        
        if (celestialPerk === 'Divine Blessing' && (parentAgeA === Age.CELESTIAL || parentAgeB === Age.CELESTIAL)) {
            const rareManes = ['Fiery', 'Silk', 'Regal'];
            const commonManes = ['Natural', 'Half'];
            rareManes.forEach(mane => { if (odds[mane] !== undefined) odds[mane] += 5; });
            commonManes.forEach(mane => { if (odds[mane] !== undefined) odds[mane] -= 2.5; }); // balance the bonus
        }
        
        let total = Object.values(odds).reduce((sum, val) => sum + (val > 0 ? val : 0), 0);
        if (total === 0) return { 'Natural': 100 };
        Object.keys(odds).forEach(key => { odds[key] = Math.max(0, (odds[key] / total) * 100); });

        return odds;
    }

    function getElementOdds(elementA, elementB) {
        const odds = {};
        Object.values(Element).forEach(elem => {
            let chance = 5;
            if (elem === elementA) chance += 40;
            if (elem === elementB) chance += 40;
            odds[elem] = chance;
        });
        let total = Object.values(odds).reduce((sum, val) => sum + val, 0);
        Object.keys(odds).forEach(key => { odds[key] = (odds[key] / total) * 100; });
        return odds;
    }

    function calculateInfertility(parentA, parentB, coiString) {
         const coiMap = { 'None': 0, 'Slight': 15, 'Medium': 30, 'High': 50 };
         let infertility = coiMap[coiString] || 0;
         if (parentA.age === Age.ADOLESCENT || parentB.age === Age.ADOLESCENT) infertility += 20;
         return Math.min(infertility, 100);
    }
    
    function rollOffspring(possibilities, parentA, parentB, items, coiString) {
        try {
            if (parentA.age === Age.ADOLESCENT || parentB.age === Age.ADOLESCENT) {
                if (Math.random() < 0.2) {
                    return '<h4>Breeding Failed!</h4><p>The offspring were stillborn due to the parents’ young age.</p>';
                }
            }
    
            const clutchParts = possibilities.clutch.replace(/ eggs?/, '').split(' - ');
            const min = parseInt(clutchParts[0], 10);
            const max = parseInt(clutchParts[1] || clutchParts[0], 10);
            let clutchSize = Math.floor(Math.random() * (max - min + 1)) + min;
    
            const infertility = possibilities.infertility;
            if (Math.random() * 100 < infertility) clutchSize = Math.floor(clutchSize / 2);
            if (infertility >= 100) clutchSize = 0;
    
            if (clutchSize === 0) {
                return `<h4>Breeding Failed! (Infertility: ${infertility.toFixed(2)}%)</h4><p>No offspring were produced.</p>`;
            }
    
            let results = `<h4>Rolled a clutch of ${clutchSize}! (Infertility: ${infertility.toFixed(2)}%)</h4>`;
            
            const rollFromOdds = (odds) => {
                const rand = Math.random() * 100;
                let cumulative = 0;
                for (const [key, value] of Object.entries(odds)) {
                    cumulative += value;
                    if (rand < cumulative) return key;
                }
                return Object.keys(odds)[0]; 
            };
    
            for (let i = 1; i <= clutchSize; i++) {
                const rolledBreed = rollFromOdds(possibilities.breeds);
                const scientificName = ScientificNames[rolledBreed] || rolledBreed;
                const rolledSex = rollFromOdds(possibilities.sex);
                const rolledMane = rollFromOdds(possibilities.manes);
                const rolledElement = rollFromOdds(possibilities.elements);
    
                let offspringGenotypeArray = [];
                for (const locus in possibilities.genotypeOdds) {
                    const rolledAllelePair = rollFromOdds(Object.fromEntries(possibilities.genotypeOdds[locus]));
                     if (rolledAllelePair !== 'n/n') {
                         offspringGenotypeArray.push(rolledAllelePair);
                     }
                }

                // Spontaneous Mutation Roll
                const perkA = AgePerks[parentA.age] || {};
                const perkB = AgePerks[parentB.age] || {};
                const mutationChance = Math.max(perkA.mutation_bonus || 0, perkB.mutation_bonus || 0);
                if (Math.random() * 100 < mutationChance) {
                    const newMutationAllele = SpontaneousMutations[Math.floor(Math.random() * SpontaneousMutations.length)];
                    const existing = offspringGenotypeArray.find(g => g.startsWith(newMutationAllele));
                    if (!existing) {
                        offspringGenotypeArray.push(`${newMutationAllele}/n`);
                    }
                }
                
                let phenotypeString = PhenotypeHelper.getPhenotype(offspringGenotypeArray, rolledMane);
                let genotypeString = offspringGenotypeArray.join(' ');

                // Defect Rolling
                let defect = 'None';
                if (coiString !== 'None') {
                    const coiPercent = calculateInfertility({}, {}, coiString);
                    if (Math.random() * 100 < coiPercent) {
                        const possibleDefects = Defects.Tiers[coiString] || [];
                        if (possibleDefects.length > 0) {
                            const defectRoll = Math.random() * 100;
                            const veryRare = possibleDefects.filter(d => Defects.VeryRare.includes(d));
                            const rare = possibleDefects.filter(d => Defects.Rare.includes(d));
                            const uncommon = possibleDefects.filter(d => Defects.Uncommon.includes(d));
                            const common = possibleDefects.filter(d => Defects.Common.includes(d));
                            
                            if (defectRoll < 5 && veryRare.length > 0) defect = veryRare[Math.floor(Math.random() * veryRare.length)];
                            else if (defectRoll < 15 && rare.length > 0) defect = rare[Math.floor(Math.random() * rare.length)];
                            else if (defectRoll < 40 && uncommon.length > 0) defect = uncommon[Math.floor(Math.random() * uncommon.length)];
                            else if (common.length > 0) defect = common[Math.floor(Math.random() * common.length)];
                            else defect = possibleDefects[Math.floor(Math.random() * possibleDefects.length)]; // Fallback
                        }
                    }
                }
    
                results += `
                    <div class="mb-3 p-3 border rounded bg-light">
                        <p class="mb-1"><strong>${i}) Species:</strong> ${scientificName}</p>
                        <p class="mb-1"><strong>Mane Type:</strong> ${rolledMane}</p>
                        <p class="mb-1"><strong>Sex:</strong> ${rolledSex}</p>
                        <p class="mb-1"><strong>Age:</strong> Hatchling</p>
                        <p class="mb-1"><strong>Inborn Element:</strong> ${rolledElement}</p>
                        <p class="mb-1"><strong>Genotype:</strong> ${genotypeString || 'None'}</p>
                        <p class="mb-1"><strong>Phenotype:</strong> ${phenotypeString}</p>
                        <p class="mb-1"><strong>Defects:</strong> ${defect}</p>
                    </div>`;
            }
            return results;
        } catch (e) { ErrorHandler.handle(e, 'rollOffspring'); return `<h4>Error!</h4><p>Failed to roll offspring: ${e.message}</p>`; }
    }

    function runBreedingCalculations(parentA, parentB, items, coiString, celestialPerk) {
        try {
            if (!parentA || !parentB) throw new Error('Missing required parameters');
            if (!AgePerks[parentA.age]?.breedable || !AgePerks[parentB.age]?.breedable) {
                throw new Error('One or both parents are too young to breed.');
            }
            
            parentA.alleles = GenotypeHelper.getAlleles(GenotypeHelper.sliceGenotype(parentA.genotype), loci);
            parentB.alleles = GenotypeHelper.getAlleles(GenotypeHelper.sliceGenotype(parentB.genotype), loci);
            parentA.celestialPerk = celestialPerk;
            parentB.celestialPerk = celestialPerk;
            
            const possibilities = {
                infertility: calculateInfertility(parentA, parentB, coiString),
                clutch: PunnettHelper.getPossibleClutchSize(parentA, parentB, items),
                breeds: PunnettHelper.getBreedOdds(parentA, parentB, celestialPerk),
                sex: PunnettHelper.getSexOdds(),
                manes: getManeOdds(parentA.mane, parentB.mane, celestialPerk, parentA.age, parentB.age),
                elements: getElementOdds(parentA.element, parentB.element),
                traits: getTraitOdds(items, parentA, parentB),
                genotypeOdds: PunnettHelper.getPunnettOdds(parentA, parentB)
            };

            const results = rollOffspring(possibilities, parentA, parentB, items, coiString);
            return { resultsHtml: results };
        } catch (e) { ErrorHandler.handle(e, 'runBreedingCalculations'); return { error: `Breeding calculation failed: ${e.message}` }; }
    }

    document.getElementById('calculate-btn').addEventListener('click', () => {
        document.getElementById('error-message').style.display = 'none';
        
        const parentA = {
            species: document.getElementById('parentA-species').value,
            age: document.getElementById('parentA-age').value,
            mane: document.getElementById('parentA-mane').value,
            element: document.getElementById('parentA-element').value,
            genotype: document.getElementById('parentA-genotype').value
        };

        const parentB = {
            species: document.getElementById('parentB-species').value,
            age: document.getElementById('parentB-age').value,
            mane: document.getElementById('parentB-mane').value,
            element: document.getElementById('parentB-element').value,
            genotype: document.getElementById('parentB-genotype').value
        };

        const items = {
            crescent_herb: document.getElementById('crescent-herb').checked,
            moonlit_herb: document.getElementById('moonlit-herb').checked
        };

        const coi = document.getElementById('coi').value;
        const celestialPerk = document.getElementById('celestial-perk').value;

        const result = runBreedingCalculations(parentA, parentB, items, coi, celestialPerk);
        if (result.error) {
            document.getElementById('error-message').style.display = 'block';
            document.getElementById('error-message').innerText = result.error;
            document.getElementById('results').innerHTML = '';
        } else {
            document.getElementById('results').innerHTML = result.resultsHtml;
        }
    });
</script>
</body>
</html>
```
</html>
    </script>
</body>
</html>

