<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Egg Generator</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body { padding: 20px; background-color: #f8f9fa; }
        .container { max-width: 600px; }
        .form-section { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .results-section { margin-top: 20px; }
        .form-select, .btn { margin-bottom: 15px; }
        .error-message { color: red; display: none; }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="mb-4">Random Egg Generator</h1>
        <div class="form-section">
            <label for="egg-type">Egg Type:</label>
            <select id="egg-type" class="form-select">
                <option value="Common">Common</option>
            </select>
            <button id="roll-btn" class="btn btn-primary me-2">Roll</button>
            <button id="reset-btn" class="btn btn-secondary">Reset</button>
            <div id="error-message" class="error-message mt-2"></div>
        </div>
        <div id="results" class="results-section"></div>
    </div>

    <script>
        try {
            // Configuration constants
            const CONFIG = {
                LOGGING: {
                    ENABLED: true,
                    PREFIX: '[EggGenerator]'
                }
            };

            // Simple logger
            const Logger = {
                log: (message) => {
                    if (CONFIG.LOGGING.ENABLED) {
                        console.log(message);
                    }
                }
            };

            // Error Handler
            class ErrorHandler {
                static handle(error, context) {
                    const message = `${CONFIG.LOGGING.PREFIX} Error in ${context}: ${error.message}\nStack: ${error.stack}`;
                    if (CONFIG.LOGGING.ENABLED) Logger.log(message);
                    document.getElementById('error-message').style.display = 'block';
                    document.getElementById('error-message').innerText = `Error: ${error.message}`;
                    return message;
                }
            }

            // Enums and Data
            const Sex = { MALE: 'Male', FEMALE: 'Female' };
            const Breed = { THIL: 'Thilyarem' };
            const ScientificNames = {
                [Breed.THIL]: 'Panlongus lykophus pelagius'
            };
            const Element = { 
                FIRE: 'Fire', WATER: 'Water', AIR: 'Air', EARTH: 'Earth', METAL: 'Metal', 
                WOOD: 'Wood', ICE: 'Ice', LIGHTNING: 'Lightning', LIGHT: 'Light', 
                SHADOW: 'Shadow', AETHER: 'Aether', VERDANT: 'Verdant' 
            };
            const GeneType = { BASE: 0, MARKING: 1, MUTATION: 2, MANE: 3, TRAIT: 4 };

            const GeneMap = {
                TAN: { 
                    TEXT: 'Tan', 
                    TYPE: GeneType.BASE, 
                    RARITY: 'common', 
                    EXPRESSED_SETS: [['B+/B+', 'M+/M+'], ['B+/B+', 'M+/M0'], ['B+/BA', 'M+/M+'], ['B+/BA', 'M+/M0']] 
                },
                CREAM: { 
                    TEXT: 'Cream', 
                    TYPE: GeneType.BASE, 
                    RARITY: 'common', 
                    EXPRESSED_SETS: [['B+/B+', 'M0/M0'], ['B+/BA', 'M0/M0']] 
                },
                DAPPLES: { 
                    TEXT: 'Dapples', 
                    TYPE: GeneType.MARKING, 
                    RARITY: 'common', 
                    EXPRESSED_SETS: [['Dpl/Dpl'], ['Dpl/n']] 
                },
                VITILIGO: { 
                    TEXT: 'Vitiligo', 
                    TYPE: GeneType.MUTATION, 
                    RARITY: 'common', 
                    EXPRESSED_SETS: [['Vit/Vit'], ['Vit/n']] 
                },
                NATURAL: { 
                    TEXT: 'Natural', 
                    TYPE: GeneType.MANE, 
                    RARITY: 'common' 
                },
                HORNED: { 
                    TEXT: 'Horned', 
                    TYPE: GeneType.TRAIT, 
                    RARITY: 'uncommon', 
                    EXPRESSED_SETS: [['Hr/Hr'], ['Hr/n']] 
                }
            };

            const loci = [
                { 
                    locus: 'B', 
                    category: 'base', 
                    null_allele: 'n', 
                    genes: [
                        { allele: 'B+', homozygous_genotype: 'B+/B+', heterozygous_genotypes: ['B+/BA'] },
                        { allele: 'BA', homozygous_genotype: 'BA/BA', heterozygous_genotypes: [] }
                    ]
                },
                { 
                    locus: 'M', 
                    category: 'base', 
                    null_allele: 'n', 
                    genes: [
                        { allele: 'M+', homozygous_genotype: 'M+/M+', heterozygous_genotypes: ['M+/M0'] },
                        { allele: 'M0', homozygous_genotype: 'M0/M0', heterozygous_genotypes: [] }
                    ]
                },
                { 
                    locus: 'K', 
                    category: 'base', 
                    null_allele: 'n', 
                    genes: [
                        { allele: 'K+', homozygous_genotype: 'K+/K+', heterozygous_genotypes: [] }
                    ]
                },
                { 
                    locus: 'Dpl', 
                    category: 'marking', 
                    null_allele: 'n', 
                    genes: [{ allele: 'Dpl', homozygous_genotype: 'Dpl/Dpl', heterozygous_genotypes: ['Dpl/n'] }] 
                },
                { 
                    locus: 'Vit', 
                    category: 'mutation', 
                    null_allele: 'n', 
                    genes: [{ allele: 'Vit', homozygous_genotype: 'Vit/Vit', heterozygous_genotypes: ['Vit/n'] }] 
                },
                { 
                    locus: 'Hr', 
                    category: 'trait', 
                    null_allele: 'n', 
                    genes: [{ allele: 'Hr', homozygous_genotype: 'Hr/Hr', heterozygous_genotypes: ['Hr/n'] }] 
                }
            ];

            const EggRules = {
                Common: {
                    species: { [Breed.THIL]: 100 },
                    baseColors: ['Tan', 'Cream'],
                    manes: { Natural: 100 },
                    markings: ['Dapples'],
                    markingCount: [1, 2],
                    mutations: { Vitiligo: 20 },
                    traits: { Horned: 10 },
                    modifiers: {}
                }
            };

            // Helper Classes
            class PhenotypeHelper {
                static phenotypeCache = new Map();

                static getPhenotype(genes, phenotypeData, mane) {
                    try {
                        Logger.log(`${CONFIG.LOGGING.PREFIX} Calculating phenotype for genes: ${genes.join(', ')}, mane: ${mane}`);
                        if (!Array.isArray(genes) || !Array.isArray(phenotypeData) || !mane) {
                            throw new Error(`Invalid input: genes=${JSON.stringify(genes)}, mane=${mane}`);
                        }

                        const cacheKey = `${genes.join('|')}|${mane}`;
                        if (this.phenotypeCache.has(cacheKey)) {
                            Logger.log(`${CONFIG.LOGGING.PREFIX} Using cached phenotype: ${cacheKey}`);
                            return this.phenotypeCache.get(cacheKey);
                        }

                        const has = (allele) => genes.some(g => g === allele || g.includes(`/${allele}`) || g.includes(`${allele}/`));
                        
                        let baseCoat = 'Tan';
                        if (has('B+/B+') || has('B+/BA')) {
                            baseCoat = has('M0/M0') ? 'Cream' : 'Tan';
                        }

                        let expressed = [];
                        const carried = [];
                        for (const pheno of phenotypeData) {
                            if (pheno.TYPE !== GeneType.BASE && pheno.TYPE !== GeneType.MANE) {
                                if (pheno.EXPRESSED_SETS?.some(set => set.every(gene => has(gene)))) {
                                    expressed.push(pheno.TEXT);
                                }
                            }
                        }

                        let phenoString = `${baseCoat} with ${mane} Mane`;
                        const markings = expressed.filter(p => GeneMap[p.toUpperCase()]?.TYPE === GeneType.MARKING);
                        if (markings.length) phenoString += ` / ${markings.join(' / ')}`;
                        const traits = expressed.filter(p => GeneMap[p.toUpperCase()]?.TYPE === GeneType.TRAIT);
                        if (traits.length) phenoString += ` [${traits.join(', ')}]`;
                        const mutations = expressed.filter(p => GeneMap[p.toUpperCase()]?.TYPE === GeneType.MUTATION);
                        if (mutations.length) phenoString += ` {${mutations.join(', ')}}`;
                        if (carried.length) phenoString += ` (${carried.join(', ')})`;

                        this.phenotypeCache.set(cacheKey, phenoString);
                        Logger.log(`${CONFIG.LOGGING.PREFIX} Phenotype calculated: ${phenoString}`);
                        return phenoString;
                    } catch (e) {
                        ErrorHandler.handle(e, 'getPhenotype');
                        return 'Error calculating phenotype';
                    }
                }
            }

            class GeneticsService {
                static loci = [];
                static phenotypes = [];

                static load() {
                    try {
                        Logger.log(`${CONFIG.LOGGING.PREFIX} Loading GeneticsService`);
                        this.loci = loci;
                        this.phenotypes = Object.values(GeneMap);
                        Logger.log(`${CONFIG.LOGGING.PREFIX} GeneticsService loaded: ${this.loci.length} loci, ${this.phenotypes.length} phenotypes`);
                    } catch (e) {
                        ErrorHandler.handle(e, 'GeneticsService.load');
                    }
                }
            }

            function rollFromOdds(odds) {
                try {
                    Logger.log(`${CONFIG.LOGGING.PREFIX} Rolling from odds: ${JSON.stringify(odds)}`);
                    const rand = Math.random() * 100;
                    let cumulative = 0;
                    for (const [key, value] of Object.entries(odds)) {
                        cumulative += value;
                        if (rand < cumulative) {
                            Logger.log(`${CONFIG.LOGGING.PREFIX} Selected: ${key}`);
                            return key;
                        }
                    }
                    const defaultKey = Object.keys(odds)[0];
                    Logger.log(`${CONFIG.LOGGING.PREFIX} Defaulting to: ${defaultKey}`);
                    return defaultKey;
                } catch (e) {
                    ErrorHandler.handle(e, 'rollFromOdds');
                    return Object.keys(odds)[0];
                }
            }

            function getRandomElement() {
                const elements = Object.values(Element);
                const selected = elements[Math.floor(Math.random() * elements.length)];
                Logger.log(`${CONFIG.LOGGING.PREFIX} Random element: ${selected}`);
                return selected;
            }

            function getRandomMarkings(availableMarkings, minCount, maxCount) {
                try {
                    Logger.log(`${CONFIG.LOGGING.PREFIX} Generating markings: ${availableMarkings.join(', ')}, min: ${minCount}, max: ${maxCount}`);
                    const count = Math.floor(Math.random() * (maxCount - minCount + 1)) + minCount;
                    const shuffled = availableMarkings.sort(() => Math.random() - 0.5);
                    const selected = shuffled.slice(0, count).map(m => {
                        const gene = GeneMap[m.toUpperCase()];
                        if (!gene) throw new Error(`Invalid marking: ${m}`);
                        const isHomozygous = Math.random() < 0.5;
                        const set = gene.EXPRESSED_SETS[isHomozygous ? 0 : 1][0];
                        Logger.log(`${CONFIG.LOGGING.PREFIX} Selected marking: ${m} -> ${set}`);
                        return set;
                    });
                    Logger.log(`${CONFIG.LOGGING.PREFIX} Markings selected: ${selected.join(', ')}`);
                    return selected;
                } catch (e) {
                    ErrorHandler.handle(e, 'getRandomMarkings');
                    return [];
                }
            }

            function getRandomGenotype(rules, rolledSpecies) {
                try {
                    Logger.log(`${CONFIG.LOGGING.PREFIX} Generating genotype for species: ${rolledSpecies}`);
                    const genotype = [];
                    const baseLoci = loci.filter(l => l.category === 'base');
                    const markingLoci = loci.filter(l => l.category === 'marking' && rules.markings.includes(GeneMap[l.locus]?.TEXT));
                    const mutationLoci = loci.filter(l => l.category === 'mutation' && rules.mutations[GeneMap[l.locus]?.TEXT]);
                    const traitLoci = loci.filter(l => l.category === 'trait' && rules.traits[GeneMap[l.locus]?.TEXT]);

                    // Base color
                    const baseOdds = Object.fromEntries(rules.baseColors.map(c => [c, 100 / rules.baseColors.length]));
                    const rolledBase = rollFromOdds(baseOdds);
                    const baseGene = GeneMap[rolledBase.toUpperCase()];
                    if (!baseGene) throw new Error(`Invalid base color: ${rolledBase}`);
                    const baseSet = baseGene.EXPRESSED_SETS[Math.floor(Math.random() * baseGene.EXPRESSED_SETS.length)];
                    Logger.log(`${CONFIG.LOGGING.PREFIX} Base color: ${rolledBase}, genes: ${baseSet.join(', ')}`);
                    baseSet.forEach(g => genotype.push(g));

                    // Markings
                    const rolledMarkings = getRandomMarkings(rules.markings, rules.markingCount[0], rules.markingCount[1]);
                    genotype.push(...rolledMarkings);

                    // Mutations
                    for (const mutation in rules.mutations) {
                        if (Math.random() * 100 < rules.mutations[mutation]) {
                            const gene = GeneMap[mutation.toUpperCase()];
                            if (!gene) throw new Error(`Invalid mutation: ${mutation}`);
                            const set = gene.EXPRESSED_SETS[Math.random() < 0.5 ? 0 : 1][0];
                            Logger.log(`${CONFIG.LOGGING.PREFIX} Mutation added: ${mutation} -> ${set}`);
                            genotype.push(set);
                        }
                    }

                    // Traits
                    const rolledTraits = Object.keys(rules.traits).filter(t => Math.random() * 100 < rules.traits[t]);
                    rolledTraits.forEach(t => {
                        const gene = GeneMap[t.toUpperCase()];
                        if (!gene) throw new Error(`Invalid trait: ${t}`);
                        const set = gene.EXPRESSED_SETS[Math.random() < 0.5 ? 0 : 1][0];
                        Logger.log(`${CONFIG.LOGGING.PREFIX} Trait added: ${t} -> ${set}`);
                        genotype.push(set);
                    });

                    // Ensure K locus is always present
                    if (!genotype.some(g => g.startsWith('K'))) {
                        Logger.log(`${CONFIG.LOGGING.PREFIX} Adding default K locus: K+/K+`);
                        genotype.push('K+/K+');
                    }

                    Logger.log(`${CONFIG.LOGGING.PREFIX} Final genotype: ${genotype.join(' ')}`);
                    return genotype;
                } catch (e) {
                    ErrorHandler.handle(e, 'getRandomGenotype');
                    return ['K+/K+'];
                }
            }

            function rollEgg(eggType) {
                try {
                    Logger.log(`${CONFIG.LOGGING.PREFIX} Rolling egg for type: ${eggType}`);
                    GeneticsService.load();
                    const rules = EggRules[eggType];
                    if (!rules) throw new Error(`Invalid egg type: ${eggType}`);

                    const rolledSpecies = rollFromOdds(rules.species);
                    const scientificName = ScientificNames[rolledSpecies] || rolledSpecies;
                    const rolledSex = Math.random() < 0.5 ? Sex.MALE : Sex.FEMALE;
                    const rolledElement = getRandomElement();
                    const rolledMane = rules.manes[rolledSpecies] ? rollFromOdds(rules.manes[rolledSpecies]) : rollFromOdds(rules.manes);
                    
                    Logger.log(`${CONFIG.LOGGING.PREFIX} Rolled: species=${rolledSpecies}, mane=${rolledMane}, sex=${rolledSex}, element=${rolledElement}`);

                    const genotype = getRandomGenotype(rules, rolledSpecies);
                    const phenotype = PhenotypeHelper.getPhenotype(genotype, GeneticsService.phenotypes, rolledMane);
                    const traits = genotype
                        .filter(g => loci.find(l => l.locus === g.split('/')[0] && l.category === 'trait'))
                        .map(g => GeneMap[loci.find(l => l.locus === g.split('/')[0]).locus].TEXT)
                        .join(', ') || 'None';

                    const result = `
                        <div class="mb-3 p-3 border rounded bg-light">
                            <h4>${eggType} Egg Hatched!</h4>
                            <p class="mb-1"><strong>Species:</strong> ${scientificName}</p>
                            <p class="mb-1"><strong>Mane Type:</strong> ${rolledMane}</p>
                            <p class="mb-1"><strong>Sex:</strong> ${rolledSex}</p>
                            <p class="mb-1"><strong>Age:</strong> Hatchling</p>
                            <p class="mb-1"><strong>Inborn Element:</strong> ${rolledElement}</p>
                            <p class="mb-1"><strong>Genotype:</strong> ${genotype.join(' ')}</p>
                            <p class="mb-1"><strong>Phenotype:</strong> ${phenotype}</p>
                            <p class="mb-1"><strong>Traits:</strong> ${traits}</p>
                        </div>`;
                    Logger.log(`${CONFIG.LOGGING.PREFIX} Egg rolled successfully`);
                    return result;
                } catch (e) {
                    ErrorHandler.handle(e, 'rollEgg');
                    return `<h4>Error!</h4><p>Failed to roll egg: ${e.message}</p>`;
                }
            }

            // Event Listeners
            document.addEventListener('DOMContentLoaded', () => {
                Logger.log(`${CONFIG.LOGGING.PREFIX} DOM fully loaded`);
                const rollBtn = document.getElementById('roll-btn');
                const resetBtn = document.getElementById('reset-btn');
                
                if (!rollBtn || !resetBtn) {
                    Logger.log(`${CONFIG.LOGGING.PREFIX} Error: Roll or Reset button not found`);
                    document.getElementById('error-message').style.display = 'block';
                    document.getElementById('error-message').innerText = 'Error: Buttons not found';
                    return;
                }

                rollBtn.addEventListener('click', () => {
                    Logger.log(`${CONFIG.LOGGING.PREFIX} Roll button clicked`);
                    document.getElementById('error-message').style.display = 'none';
                    const eggType = document.getElementById('egg-type').value;
                    Logger.log(`${CONFIG.LOGGING.PREFIX} Selected egg type: ${eggType}`);
                    const result = rollEgg(eggType);
                    document.getElementById('results').innerHTML = result;
                });

                resetBtn.addEventListener('click', () => {
                    Logger.log(`${CONFIG.LOGGING.PREFIX} Reset button clicked`);
                    document.getElementById('error-message').style.display = 'none';
                    document.getElementById('results').innerHTML = '';
                    document.getElementById('egg-type').value = 'Common';
                });
            });
        } catch (e) {
            console.error(`${CONFIG.LOGGING.PREFIX} Syntax error in script initialization: ${e.message}`);
            document.getElementById('error-message').style.display = 'block';
            document.getElementById('error-message').innerText = `Syntax Error: ${e.message}`;
        }
    </script>
</body>
</html>
